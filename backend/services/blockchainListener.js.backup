// backend/services/blockchainListener.js
const { ethers } = require('ethers');

class BlockchainListener {
  constructor() {
    this.provider = null;
    this.isConnected = false;
    this._isListening = false;
    this.watchedAddresses = new Set();
    
    // ğŸ”§ Rate Limit ê´€ë¦¬
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.rateLimitDelay = 200; // 200ms ê°„ê²©
    this.maxRequestsPerSecond = 5; // ì´ˆë‹¹ 5ê°œë¡œ ì œí•œ
    
    // ğŸ”§ ì—ëŸ¬ ê´€ë¦¬
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 10;
  }

  async initialize() {
    try {
      console.log('[BE BlockListener] ì´ˆê¸°í™” ì‹œì‘...');
      
      if (!process.env.ETHEREUM_RPC_URL) {
        console.log('[BE BlockListener] ETHEREUM_RPC_URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê°œë°œ ëª¨ë“œë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.');
        return false;
      }
      
      this.provider = new ethers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL);
      
      // ë„¤íŠ¸ì›Œí¬ í™•ì¸
      const network = await this.provider.getNetwork();
      console.log(`[BE BlockListener] ì´ë”ë¦¬ì›€ ë…¸ë“œì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤: ${network.name}`);
      
      this.isConnected = true;
      this._isListening = false;
      
      // ğŸ”§ Rate Limit ê³ ë ¤í•œ ë¸”ë¡ ë¦¬ìŠ¤ë„ˆ ì‹œì‘
      this.startOptimizedBlockListener();
      
      return true;
      
    } catch (error) {
      console.error('[BE BlockListener] ì´ˆê¸°í™” ì‹¤íŒ¨:', error.message);
      this.isConnected = false;
      return false;
    }
  }

  // ğŸ”§ ìµœì í™”ëœ ë¸”ë¡ ë¦¬ìŠ¤ë„ˆ (Rate Limit ê³ ë ¤)
  startOptimizedBlockListener() {
    if (!this.provider || this._isListening) {
      return;
    }

    try {
      console.log('[BE BlockListener] ìµœì í™”ëœ ë¸”ë¡ ë¦¬ìŠ¤ë‹ ì‹œì‘...');
      
      this.provider.on('block', async (blockNumber) => {
        try {
          console.log(`[BE BlockListener] ìƒˆ ë¸”ë¡ ìˆ˜ì‹ : ${blockNumber}`);
          
          // ğŸ”§ ê°ì‹œ ì¤‘ì¸ ì£¼ì†Œê°€ ì—†ìœ¼ë©´ íŠ¸ëœì­ì…˜ ì¡°íšŒ ìƒëµ
          if (this.watchedAddresses.size === 0) {
            console.log(`[BE BlockListener] ê°ì‹œ ì¤‘ì¸ ì£¼ì†Œ ì—†ìŒ - ë¸”ë¡ ${blockNumber} íŠ¸ëœì­ì…˜ ì¡°íšŒ ìƒëµ`);
            this.emitBlockEvent({
              blockNumber,
              transactionCount: 0,
              timestamp: Date.now()
            });
            return;
          }
          
          // ğŸ”§ Rate Limit ì²´í¬
          if (this.consecutiveErrors > this.maxConsecutiveErrors) {
            console.log(`[BE BlockListener] ì—°ì† ì˜¤ë¥˜ ${this.consecutiveErrors}íšŒ - ë¸”ë¡ ì²˜ë¦¬ ì¼ì‹œ ì¤‘ë‹¨`);
            return;
          }
          
          // ğŸ”§ ë¸”ë¡ ì •ë³´ë§Œ ê°€ì ¸ì˜¤ê¸° (íŠ¸ëœì­ì…˜ ìƒì„¸ëŠ” í•„ìš”ì‹œì—ë§Œ)
          const block = await this.safeApiCall(() => this.provider.getBlock(blockNumber, false)); // false = íŠ¸ëœì­ì…˜ í•´ì‹œë§Œ
          
          if (!block) {
            console.log(`[BE BlockListener] ë¸”ë¡ ${blockNumber} ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨`);
            return;
          }

          console.log(`[BE BlockListener] ë¸”ë¡ ${blockNumber}ì— ${block.transactions.length}ê°œ íŠ¸ëœì­ì…˜ (ìƒì„¸ ì¡°íšŒ ìƒëµ)`);
          
          // ğŸ”§ íŠ¸ëœì­ì…˜ ìƒì„¸ ì¡°íšŒëŠ” ì œí•œì ìœ¼ë¡œë§Œ ì‹¤í–‰
          if (this.watchedAddresses.size > 0 && block.transactions.length < 50) {
            // íŠ¸ëœì­ì…˜ì´ 50ê°œ ë¯¸ë§Œì¼ ë•Œë§Œ ìƒì„¸ ì¡°íšŒ
            await this.processBlockTransactionsOptimized(block);
          }

          this.emitBlockEvent({
            blockNumber,
            transactionCount: block.transactions.length,
            timestamp: block.timestamp
          });
          
          // ì„±ê³µ ì‹œ ì—ëŸ¬ ì¹´ìš´í„° ë¦¬ì…‹
          this.consecutiveErrors = 0;

        } catch (error) {
          this.consecutiveErrors++;
          console.error(`[BE BlockListener] ë¸”ë¡ ${blockNumber} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (${this.consecutiveErrors}íšŒ):`, error.message);
          
          if (error.message.includes('Too Many Requests')) {
            console.log(`[BE BlockListener] Rate Limit ê°ì§€ - ${this.rateLimitDelay * 2}ms ëŒ€ê¸°`);
            await this.sleep(this.rateLimitDelay * 2);
          }
        }
      });
      
      this._isListening = true;
      console.log('[BE BlockListener] ìµœì í™”ëœ ë¸”ë¡ ë¦¬ìŠ¤ë‹ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.');
      
    } catch (error) {
      console.error('[BE BlockListener] ë¸”ë¡ ë¦¬ìŠ¤ë„ˆ ì‹œì‘ ì‹¤íŒ¨:', error.message);
      this._isListening = false;
    }
  }

  // ğŸ”§ ì•ˆì „í•œ API í˜¸ì¶œ (Rate Limit ê³ ë ¤)
  async safeApiCall(apiFunction) {
    try {
      // Rate Limit ì²´í¬
      const now = Date.now();
      if (now - this.lastRequestTime < this.rateLimitDelay) {
        await this.sleep(this.rateLimitDelay);
      }
      
      this.lastRequestTime = Date.now();
      this.requestCount++;
      
      const result = await apiFunction();
      return result;
      
    } catch (error) {
      if (error.message.includes('Too Many Requests')) {
        console.log(`[BE BlockListener] Rate Limit ì˜¤ë¥˜ - ì ì‹œ ëŒ€ê¸°`);
        await this.sleep(1000); // 1ì´ˆ ëŒ€ê¸°
        return null;
      }
      throw error;
    }
  }

  // ğŸ”§ ìµœì í™”ëœ íŠ¸ëœì­ì…˜ ì²˜ë¦¬ (ì„ íƒì ìœ¼ë¡œë§Œ)
  async processBlockTransactionsOptimized(block) {
    try {
      // ğŸ”§ ê°ì‹œ ì¤‘ì¸ ì£¼ì†Œê°€ ì—†ìœ¼ë©´ ìƒëµ
      if (this.watchedAddresses.size === 0) {
        return;
      }

      console.log(`[BE BlockListener] ë¸”ë¡ ${block.number} - ${block.transactions.length}ê°œ íŠ¸ëœì­ì…˜ ì¤‘ ì¼ë¶€ë§Œ í™•ì¸`);
      
      // ğŸ”§ ìµœëŒ€ 5ê°œ íŠ¸ëœì­ì…˜ë§Œ í™•ì¸ (Rate Limit ê³ ë ¤)
      const transactionsToCheck = block.transactions.slice(0, 5);
      
      for (const txHash of transactionsToCheck) {
        try {
          const tx = await this.safeApiCall(() => this.provider.getTransaction(txHash));
          
          if (tx && tx.to && this.watchedAddresses.has(tx.to.toLowerCase())) {
            const amount = ethers.formatEther(tx.value);
            console.log(`[BE BlockListener] ğŸ’° ì…ê¸ˆ ê°ì§€: ${tx.to} â† ${amount} ETH`);
            
            await this.processDeposit({
              address: tx.to,
              amount: amount,
              txHash: tx.hash,
              blockNumber: block.number,
              from: tx.from
            });
          }
          
          // ê° íŠ¸ëœì­ì…˜ ì²˜ë¦¬ í›„ ì ì‹œ ëŒ€ê¸°
          await this.sleep(this.rateLimitDelay);
          
        } catch (txError) {
          if (txError.message.includes('Too Many Requests')) {
            console.log(`[BE BlockListener] Rate Limit - íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ì¤‘ë‹¨`);
            break; // Rate Limit ì‹œ ë£¨í”„ ì¤‘ë‹¨
          }
          console.error(`[BE BlockListener] íŠ¸ëœì­ì…˜ ${txHash.slice(0,10)}... ì²˜ë¦¬ ì˜¤ë¥˜:`, txError.message);
        }
      }
      
    } catch (error) {
      console.error('[BE BlockListener] ìµœì í™”ëœ íŠ¸ëœì­ì…˜ ì²˜ë¦¬ ì˜¤ë¥˜:', error.message);
    }
  }

  // ğŸ”§ ëŒ€ê¸° í•¨ìˆ˜
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // ğŸ”§ ë¸”ë¡ ì´ë²¤íŠ¸ ë°œìƒ
  emitBlockEvent(blockData) {
    try {
      if (global.io) {
        global.io.emit('newBlock', blockData);
      }
    } catch (error) {
      console.error('[BE BlockListener] ë¸”ë¡ ì´ë²¤íŠ¸ ë°œìƒ ì˜¤ë¥˜:', error.message);
    }
  }

  // ğŸ”§ ì£¼ì†Œ ê°ì‹œ ì¶”ê°€
  addWatchedAddress(address) {
    if (!address) return false;
    
    const normalizedAddress = address.toLowerCase();
    this.watchedAddresses.add(normalizedAddress);
    console.log(`[BE BlockListener] ì£¼ì†Œ ê°ì‹œ ì¶”ê°€: ${address} (ì´ ${this.watchedAddresses.size}ê°œ)`);
    return true;
  }

  // ğŸ”§ ì£¼ì†Œ ê°ì‹œ ì œê±°
  removeWatchedAddress(address) {
    if (!address) return false;
    
    const normalizedAddress = address.toLowerCase();
    const removed = this.watchedAddresses.delete(normalizedAddress);
    if (removed) {
      console.log(`[BE BlockListener] ì£¼ì†Œ ê°ì‹œ ì œê±°: ${address}`);
    }
    return removed;
  }

  async processDeposit(depositData) {
    try {
      console.log('[BE BlockListener] ğŸ’° ì…ê¸ˆ ì²˜ë¦¬:', {
        address: depositData.address,
        amount: depositData.amount,
        txHash: depositData.txHash.slice(0, 10) + '...'
      });
      
      if (global.io) {
        global.io.emit('newDeposit', {
          ...depositData,
          status: 'pending',
          confirmations: 1,
          timestamp: new Date().toISOString()
        });
      }
      
    } catch (error) {
      console.error('[BE BlockListener] ì…ê¸ˆ ì²˜ë¦¬ ì˜¤ë¥˜:', error.message);
    }
  }

  // ğŸ”§ ìƒíƒœ í™•ì¸
  get isListening() {
    return this._isListening && this.isConnected;
  }

  getStatus() {
    return {
      isConnected: this.isConnected,
      isListening: this._isListening,
      watchedAddresses: Array.from(this.watchedAddresses),
      requestCount: this.requestCount,
      consecutiveErrors: this.consecutiveErrors,
      rateLimitDelay: this.rateLimitDelay
    };
  }

  // ğŸ”§ ë¦¬ìŠ¤ë„ˆ ì¤‘ì§€
  stop() {
    try {
      if (this.provider && this._isListening) {
        this.provider.removeAllListeners('block');
        this._isListening = false;
        console.log('[BE BlockListener] ë¸”ë¡ ë¦¬ìŠ¤ë„ˆ ì¤‘ì§€ë¨');
      }
    } catch (error) {
      console.error('[BE BlockListener] ë¦¬ìŠ¤ë„ˆ ì¤‘ì§€ ì˜¤ë¥˜:', error.message);
    }
  }
}

const blockchainListener = new BlockchainListener();
module.exports = blockchainListener;