// backend/services/blockchainListener.js
const { ethers } = require('ethers');

class BlockchainListener {
  constructor() {
    this.provider = null;
    this.isConnected = false;
    this._isListening = false;
    this.watchedAddresses = new Set();
    
    // 🔧 Rate Limit 관리
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.rateLimitDelay = 200; // 200ms 간격
    this.maxRequestsPerSecond = 5; // 초당 5개로 제한
    
    // 🔧 에러 관리
    this.consecutiveErrors = 0;
    this.maxConsecutiveErrors = 10;
  }

  async initialize() {
    try {
      console.log('[BE BlockListener] 초기화 시작...');
      
      if (!process.env.ETHEREUM_RPC_URL) {
        console.log('[BE BlockListener] ETHEREUM_RPC_URL이 설정되지 않았습니다. 개발 모드로 실행됩니다.');
        return false;
      }
      
      this.provider = new ethers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL);
      
      // 네트워크 확인
      const network = await this.provider.getNetwork();
      console.log(`[BE BlockListener] 이더리움 노드에 연결되었습니다: ${network.name}`);
      
      this.isConnected = true;
      this._isListening = false;
      
      // 🔧 Rate Limit 고려한 블록 리스너 시작
      this.startOptimizedBlockListener();
      
      return true;
      
    } catch (error) {
      console.error('[BE BlockListener] 초기화 실패:', error.message);
      this.isConnected = false;
      return false;
    }
  }

  // 🔧 최적화된 블록 리스너 (Rate Limit 고려)
  startOptimizedBlockListener() {
    if (!this.provider || this._isListening) {
      return;
    }

    try {
      console.log('[BE BlockListener] 최적화된 블록 리스닝 시작...');
      
      this.provider.on('block', async (blockNumber) => {
        try {
          console.log(`[BE BlockListener] 새 블록 수신: ${blockNumber}`);
          
          // 🔧 감시 중인 주소가 없으면 트랜잭션 조회 생략
          if (this.watchedAddresses.size === 0) {
            console.log(`[BE BlockListener] 감시 중인 주소 없음 - 블록 ${blockNumber} 트랜잭션 조회 생략`);
            this.emitBlockEvent({
              blockNumber,
              transactionCount: 0,
              timestamp: Date.now()
            });
            return;
          }
          
          // 🔧 Rate Limit 체크
          if (this.consecutiveErrors > this.maxConsecutiveErrors) {
            console.log(`[BE BlockListener] 연속 오류 ${this.consecutiveErrors}회 - 블록 처리 일시 중단`);
            return;
          }
          
          // 🔧 블록 정보만 가져오기 (트랜잭션 상세는 필요시에만)
          const block = await this.safeApiCall(() => this.provider.getBlock(blockNumber, false)); // false = 트랜잭션 해시만
          
          if (!block) {
            console.log(`[BE BlockListener] 블록 ${blockNumber} 정보 조회 실패`);
            return;
          }

          console.log(`[BE BlockListener] 블록 ${blockNumber}에 ${block.transactions.length}개 트랜잭션 (상세 조회 생략)`);
          
          // 🔧 트랜잭션 상세 조회는 제한적으로만 실행
          if (this.watchedAddresses.size > 0 && block.transactions.length < 50) {
            // 트랜잭션이 50개 미만일 때만 상세 조회
            await this.processBlockTransactionsOptimized(block);
          }

          this.emitBlockEvent({
            blockNumber,
            transactionCount: block.transactions.length,
            timestamp: block.timestamp
          });
          
          // 성공 시 에러 카운터 리셋
          this.consecutiveErrors = 0;

        } catch (error) {
          this.consecutiveErrors++;
          console.error(`[BE BlockListener] 블록 ${blockNumber} 처리 중 오류 (${this.consecutiveErrors}회):`, error.message);
          
          if (error.message.includes('Too Many Requests')) {
            console.log(`[BE BlockListener] Rate Limit 감지 - ${this.rateLimitDelay * 2}ms 대기`);
            await this.sleep(this.rateLimitDelay * 2);
          }
        }
      });
      
      this._isListening = true;
      console.log('[BE BlockListener] 최적화된 블록 리스닝이 시작되었습니다.');
      
    } catch (error) {
      console.error('[BE BlockListener] 블록 리스너 시작 실패:', error.message);
      this._isListening = false;
    }
  }

  // 🔧 안전한 API 호출 (Rate Limit 고려)
  async safeApiCall(apiFunction) {
    try {
      // Rate Limit 체크
      const now = Date.now();
      if (now - this.lastRequestTime < this.rateLimitDelay) {
        await this.sleep(this.rateLimitDelay);
      }
      
      this.lastRequestTime = Date.now();
      this.requestCount++;
      
      const result = await apiFunction();
      return result;
      
    } catch (error) {
      if (error.message.includes('Too Many Requests')) {
        console.log(`[BE BlockListener] Rate Limit 오류 - 잠시 대기`);
        await this.sleep(1000); // 1초 대기
        return null;
      }
      throw error;
    }
  }

  // 🔧 최적화된 트랜잭션 처리 (선택적으로만)
  async processBlockTransactionsOptimized(block) {
    try {
      // 🔧 감시 중인 주소가 없으면 생략
      if (this.watchedAddresses.size === 0) {
        return;
      }

      console.log(`[BE BlockListener] 블록 ${block.number} - ${block.transactions.length}개 트랜잭션 중 일부만 확인`);
      
      // 🔧 최대 5개 트랜잭션만 확인 (Rate Limit 고려)
      const transactionsToCheck = block.transactions.slice(0, 5);
      
      for (const txHash of transactionsToCheck) {
        try {
          const tx = await this.safeApiCall(() => this.provider.getTransaction(txHash));
          
          if (tx && tx.to && this.watchedAddresses.has(tx.to.toLowerCase())) {
            const amount = ethers.formatEther(tx.value);
            console.log(`[BE BlockListener] 💰 입금 감지: ${tx.to} ← ${amount} ETH`);
            
            await this.processDeposit({
              address: tx.to,
              amount: amount,
              txHash: tx.hash,
              blockNumber: block.number,
              from: tx.from
            });
          }
          
          // 각 트랜잭션 처리 후 잠시 대기
          await this.sleep(this.rateLimitDelay);
          
        } catch (txError) {
          if (txError.message.includes('Too Many Requests')) {
            console.log(`[BE BlockListener] Rate Limit - 트랜잭션 처리 중단`);
            break; // Rate Limit 시 루프 중단
          }
          console.error(`[BE BlockListener] 트랜잭션 ${txHash.slice(0,10)}... 처리 오류:`, txError.message);
        }
      }
      
    } catch (error) {
      console.error('[BE BlockListener] 최적화된 트랜잭션 처리 오류:', error.message);
    }
  }

  // 🔧 대기 함수
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // 🔧 블록 이벤트 발생
  emitBlockEvent(blockData) {
    try {
      if (global.io) {
        global.io.emit('newBlock', blockData);
      }
    } catch (error) {
      console.error('[BE BlockListener] 블록 이벤트 발생 오류:', error.message);
    }
  }

  // 🔧 주소 감시 추가
  addWatchedAddress(address) {
    if (!address) return false;
    
    const normalizedAddress = address.toLowerCase();
    this.watchedAddresses.add(normalizedAddress);
    console.log(`[BE BlockListener] 주소 감시 추가: ${address} (총 ${this.watchedAddresses.size}개)`);
    return true;
  }

  // 🔧 주소 감시 제거
  removeWatchedAddress(address) {
    if (!address) return false;
    
    const normalizedAddress = address.toLowerCase();
    const removed = this.watchedAddresses.delete(normalizedAddress);
    if (removed) {
      console.log(`[BE BlockListener] 주소 감시 제거: ${address}`);
    }
    return removed;
  }

  async processDeposit(depositData) {
    try {
      console.log('[BE BlockListener] 💰 입금 처리:', {
        address: depositData.address,
        amount: depositData.amount,
        txHash: depositData.txHash.slice(0, 10) + '...'
      });
      
      if (global.io) {
        global.io.emit('newDeposit', {
          ...depositData,
          status: 'pending',
          confirmations: 1,
          timestamp: new Date().toISOString()
        });
      }
      
    } catch (error) {
      console.error('[BE BlockListener] 입금 처리 오류:', error.message);
    }
  }

  // 🔧 상태 확인
  get isListening() {
    return this._isListening && this.isConnected;
  }

  getStatus() {
    return {
      isConnected: this.isConnected,
      isListening: this._isListening,
      watchedAddresses: Array.from(this.watchedAddresses),
      requestCount: this.requestCount,
      consecutiveErrors: this.consecutiveErrors,
      rateLimitDelay: this.rateLimitDelay
    };
  }

  // 🔧 리스너 중지
  stop() {
    try {
      if (this.provider && this._isListening) {
        this.provider.removeAllListeners('block');
        this._isListening = false;
        console.log('[BE BlockListener] 블록 리스너 중지됨');
      }
    } catch (error) {
      console.error('[BE BlockListener] 리스너 중지 오류:', error.message);
    }
  }
}

const blockchainListener = new BlockchainListener();
module.exports = blockchainListener;